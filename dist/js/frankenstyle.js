(()=>{const breakpoints={sm:"40rem",md:"48rem",lg:"64rem",xl:"80rem","2xl":"96rem"};const aliases={w:"width",h:"height",m:"margin",p:"padding","[p]":"padding",bg:"background-color",color:"color"};const withScaling=new Set(["m","p"]);const withDark=new Set(["background-color","color"]);const excludedVars=new Set(["spacing"]);const ruleTemplates={".bg":{"background-color":"color-mix(in oklab,var(--bg-{s})var(--bg-opacity-{s},100%),transparent)"},".color":{color:"color-mix(in oklab,var(--color-{s})var(--color-opacity-{s},100%),transparent)"}};function extractCSSVariables(rules){const variables=new Set;for(const ruleSet of Object.values(rules)){for(const value of Object.values(ruleSet)){const matches=value.match(/--([a-zA-Z][a-zA-Z0-9-]*)-\{s\}/g);if(matches){matches.forEach(match=>{const varName=match.replace("--","").replace("-{s}","");if(!excludedVars.has(varName)){variables.add(varName)}})}}}return variables}function buildVariableChain(bp,variable,order,i,dark=false){const darkPrefix=dark?"dark-":"";const escapedBp=bp==="2xl"?"\\32xl":bp;let chain=`var(--${darkPrefix}${escapedBp}-${variable}`;for(let j=i-1;j>=0;j--){const prev=order[j];const escapedPrev=prev==="2xl"?"\\32xl":prev;chain+=`, var(--${darkPrefix}${escapedPrev}-${variable}`}chain+=`, var(--${variable})`;chain+=")".repeat(i+1);return chain}function expandRuleTemplates(base,breakpoints,withDark){const order=Object.keys(breakpoints);const expanded={...base};const cssVariables=extractCSSVariables(base);for(const[selector,rules]of Object.entries(base)){for(let i=0;i<order.length;i++){const bp=order[i];const escapedBp=bp==="2xl"?"\\32xl":bp;const bpSelector=`.${escapedBp}\\:${selector.slice(1)}`;expanded[bpSelector]={};for(const[prop,value]of Object.entries(rules)){let expandedValue=value;for(const variable of cssVariables){const pattern=new RegExp(`var\\(--${variable}-\\{s\\}\\)`,"g");if(expandedValue.match(pattern)){const chain=buildVariableChain(bp,variable,order,i);expandedValue=expandedValue.replace(pattern,chain)}}expanded[bpSelector][prop]=expandedValue;if(withDark.has(prop)){const darkSelector=`.dark ${bpSelector}`;let darkValue=value;for(const variable of cssVariables){const pattern=new RegExp(`var\\(--${variable}-\\{s\\}\\)`,"g");if(darkValue.match(pattern)){const darkChain=buildVariableChain(bp,variable,order,i,true);darkValue=darkValue.replace(pattern,darkChain)}}if(!expanded[darkSelector]){expanded[darkSelector]={}}expanded[darkSelector][prop]=darkValue}}}for(const[prop,value]of Object.entries(rules)){if(withDark.has(prop)){let baseDarkValue=value;for(const variable of cssVariables){const pattern=new RegExp(`var\\(--${variable}-\\{s\\}\\)`,"g");if(baseDarkValue.match(pattern)){baseDarkValue=baseDarkValue.replace(pattern,`var(--dark-${variable}-{s}, var(--${variable}-{s}))`)}}const darkSelector=`.dark ${selector}`;if(!expanded[darkSelector]){expanded[darkSelector]={}}expanded[darkSelector][prop]=baseDarkValue}}}return expanded}const whitelist=expandRuleTemplates(ruleTemplates,breakpoints,withDark);const ruleCache=new Map;let pendingMutations=new Set;let mutationBatchTimeout=null;function stripBrackets(propAlias){return propAlias.replace(/^\[|\]$/g,"")}function applyStateToWhitelist(ruleObj,state){const updated={};let needDark=false;for(const[prop,val]of Object.entries(ruleObj)){updated[prop]=val.replace(/{s}/g,state);if(withDark.has(prop)){needDark=true}}let darkVariant=null;if(needDark){darkVariant={};for(const[prop,val]of Object.entries(ruleObj)){let darkVal=val.replace(/{s}/g,state);darkVal=darkVal.replace(/var\((--[a-z0-9-]+)([^)]*)\)/gi,(match,varName,rest)=>{if(excludedVars.has(varName)){return match}const darkName=`--dark-${varName.slice(2)}`;return`var(${darkName}, var(${varName}${rest}))`});darkVariant[prop]=darkVal}}return{updated:updated,darkVariant:darkVariant}}function buildNestedFallback(varNames){if(varNames.length===1){return`var(${varNames[0]})`}return varNames.reduceRight((acc,varName)=>acc?`var(${varName}, ${acc})`:`var(${varName})`)}function buildDarkFallback(varNames,propAlias,state){const darkVars=varNames.map(varName=>{const match=varName.match(/^--(.+?)(-\w+)?$/);if(!match){return varName}const[,base]=match;return`--dark-${base}-${state}`});const normalFallback=buildNestedFallback(varNames);return darkVars.reduceRight((acc,darkVar)=>acc?`var(${darkVar}, ${acc})`:`var(${darkVar}, ${normalFallback})`)}function escapeClassName(name){if(typeof CSS!=="undefined"&&typeof CSS.escape==="function"){return CSS.escape(name)}let s=name.replace(/[:\s]/g,"\\$&");if(/^\d/.test(s)){const hex=name.charCodeAt(0).toString(16);s=`\\${hex} ${s.slice(1)}`}return s}function buildCSSBlock(selector,ruleObj){const cacheKey=`${selector}:${JSON.stringify(ruleObj)}`;if(ruleCache.has(cacheKey)){return ruleCache.get(cacheKey)}const block=`${selector} {\n`+Object.entries(ruleObj).map(([k,v])=>`  ${k}: ${v};`).join("\n")+`\n}`;if(ruleCache.size>1e3){const firstKey=ruleCache.keys().next().value;ruleCache.delete(firstKey)}ruleCache.set(cacheKey,block);return block}const classPartsRegex=/\s+/;function getClassProcessingKey(cls,breakpoint,propAlias,state){return`${cls}|${breakpoint||""}|${propAlias}|${state}`}function generateInteractiveStyles(){const nodes=document.querySelectorAll("[data-fs-interactive]");nodes.forEach(node=>{if(!node.style.contain){node.style.contain="style"}});const blocksByBp=new Map;const processedClasses=new Set;const pushBlock=(bpKey,blockText)=>{if(!blocksByBp.has(bpKey))blocksByBp.set(bpKey,[]);blocksByBp.get(bpKey).push(blockText)};nodes.forEach(node=>{const classes=String(node.className||"").split(classPartsRegex).filter(Boolean);classes.forEach(cls=>{if(!cls.includes(":")){return}const parts=cls.split(":").filter(Boolean);if(parts.length<2){return}let state=null;let breakpoint=null;let propAlias=null;if(parts.length===2){[propAlias,state]=parts}else if(parts.length===3){[breakpoint,propAlias,state]=parts}else{state=parts.pop();propAlias=parts.pop();breakpoint=parts.length?parts.join(":"):null}if(!state||!propAlias){return}const classKey=getClassProcessingKey(cls,breakpoint,propAlias,state);if(processedClasses.has(classKey)){return}processedClasses.add(classKey);const selectorKey=breakpoint?`.${breakpoint}.${propAlias}`:`.${propAlias}`;const whitelistRule=whitelist[selectorKey];const darkWhitelistRule=whitelist[`.dark ${selectorKey}`];if(whitelistRule){normalRuleObj={};for(const[prop,val]of Object.entries(whitelistRule)){normalRuleObj[prop]=val.replace(/{s}/g,state)}if(darkWhitelistRule){darkRuleObj={};for(const[prop,val]of Object.entries(darkWhitelistRule)){darkRuleObj[prop]=val.replace(/{s}/g,state)}}}else{const cssProp=aliases[propAlias];if(!cssProp){console.warn(`Unknown property alias: ${propAlias} (from ${cls})`);return}const shouldScale=withScaling.has(propAlias);const cleanPropAlias=stripBrackets(propAlias);let varNames;if(breakpoint){const bpOrder=["2xl","xl","lg","md","sm"];const startIndex=bpOrder.indexOf(breakpoint);if(startIndex===-1){varNames=[`--${breakpoint}-${cleanPropAlias}-${state}`]}else{varNames=[];for(let i=startIndex;i<bpOrder.length;i++){varNames.push(`--${bpOrder[i]}-${cleanPropAlias}-${state}`)}varNames.push(`--${cleanPropAlias}-${state}`)}}else{varNames=[`--${cleanPropAlias}-${state}`]}const nestedFallback=buildNestedFallback(varNames);if(shouldScale){normalRuleObj={[cssProp]:`calc(var(--spacing) * ${nestedFallback})`}}else{normalRuleObj={[cssProp]:nestedFallback}}if(withDark.has(cssProp)){const darkFallback=buildDarkFallback(varNames,cleanPropAlias,state);darkRuleObj={[cssProp]:shouldScale?`calc(var(--spacing) * ${darkFallback})`:darkFallback}}}const esc=escapeClassName(cls);const normalSelector=`.${esc}:${state}`;const normalBlock=buildCSSBlock(normalSelector,normalRuleObj);if(darkRuleObj){const darkSelector=`.dark .${esc}:${state}`;const darkBlock=buildCSSBlock(darkSelector,darkRuleObj);if(breakpoint&&breakpoints[breakpoint]){pushBlock(breakpoint,darkBlock)}else{pushBlock("base",darkBlock)}}if(breakpoint&&breakpoints[breakpoint]){pushBlock(breakpoint,normalBlock)}else{pushBlock("base",normalBlock)}})});const parts=[];const baseBlocks=blocksByBp.get("base");if(baseBlocks?.length){parts.push(...baseBlocks)}const orderedBps=["sm","md","lg","xl","2xl"];for(const bp of orderedBps){const arr=blocksByBp.get(bp);if(!arr?.length){continue}const joined=arr.join("\n\n");parts.push(`@media (min-width: ${breakpoints[bp]}) {\n${joined}\n}`)}const finalCss=parts.length?"@layer styles {\n"+parts.join("\n\n")+"\n}":"";requestAnimationFrame(()=>{let styleTag=document.getElementById("fs-interactive-styles");if(!styleTag){styleTag=document.createElement("style");styleTag.id="fs-interactive-styles";document.head.appendChild(styleTag)}styleTag.textContent=finalCss})}let scheduled=null;function handleMutations(mutationsList){let hasRelevantChanges=false;for(const mutation of mutationsList){if(mutation.type==="attributes"){const{attributeName:attributeName,target:target}=mutation;if(attributeName==="class"||attributeName==="data-fs-interactive"){pendingMutations.add(target);hasRelevantChanges=true}}else if(mutation.type==="childList"){const checkNodes=[...mutation.addedNodes,...mutation.removedNodes];for(const node of checkNodes){if(node.nodeType===1){if(node.hasAttribute?.("data-fs-interactive")||node.querySelector?.("[data-fs-interactive]")){hasRelevantChanges=true;break}}}}}if(hasRelevantChanges){scheduleGenerate()}}function scheduleGenerate(){if(scheduled){clearTimeout(scheduled)}scheduled=setTimeout(()=>{scheduled=null;pendingMutations.clear();generateInteractiveStyles()},60)}function init(){generateInteractiveStyles();const observer=new MutationObserver(handleMutations);observer.observe(document.body,{childList:true,subtree:true,attributes:true,attributeFilter:["data-fs-interactive","class"]});const cleanup=()=>{observer.disconnect();if(scheduled){clearTimeout(scheduled)}pendingMutations.clear();ruleCache.clear()};window.addEventListener("beforeunload",cleanup);window.__fsInteractive={regenerate:generateInteractiveStyles,stop:cleanup,clearCache:()=>ruleCache.clear(),getCacheSize:()=>ruleCache.size,getPendingMutations:()=>Array.from(pendingMutations)}}if(document.readyState==="loading"){document.addEventListener("DOMContentLoaded",init)}else{init()}})();